<!DOCTYPE html><html lang="en"><head><title>3-tree/1-base/2-Deep</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../"><meta name="groc-document-path" content="3-tree/1-base/2-Deep"><meta name="groc-project-path" content="js/src/3-tree/1-base/2-Deep.js"><meta name="groc-github-url" content="https://github.com/aureooms/js-fingertree"><link rel="stylesheet" type="text/css" media="all" href="../../assets/style.css"><script type="text/javascript" src="../../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/aureooms/js-fingertree/blob/master/js/src/3-tree/1-base/2-Deep.js">js/src/3-tree/1-base/2-Deep.js</a></div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deep</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tree</span> </span>{

	constructor ( M , left , middle , right ) {
		<span class="hljs-keyword">super</span>( ) ;
		<span class="hljs-keyword">this</span>.M = M ;
		<span class="hljs-keyword">this</span>.left = left ;
		<span class="hljs-keyword">this</span>.middle = middle ;
		<span class="hljs-keyword">this</span>.right = right ;
		<span class="hljs-keyword">this</span>.v = <span class="hljs-literal">null</span> ;
	}

	measure ( ) {

		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.v === <span class="hljs-literal">null</span> ) {

			<span class="hljs-keyword">const</span> M = <span class="hljs-keyword">this</span>.M ;

			<span class="hljs-keyword">this</span>.v = M.plus(
				<span class="hljs-keyword">this</span>.left.measure( M ) ,
				M.plus(
					<span class="hljs-keyword">this</span>.middle.measure( ) ,
					<span class="hljs-keyword">this</span>.right.measure( M )
				)
			) ;

		}

		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.v ;

	}

	empty ( ) {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> ;
	}

	head ( ) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.left.head( ) ;
	}

	last ( ) {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.right.last( ) ;
	}

	tail ( ) {

		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.left <span class="hljs-keyword">instanceof</span> One ) {

			<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.middle.empty( ) ) {
				<span class="hljs-keyword">return</span> _from_digit( <span class="hljs-keyword">this</span>.M , <span class="hljs-keyword">this</span>.right ) ;
			}

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Deep( <span class="hljs-keyword">this</span>.M , <span class="hljs-keyword">this</span>.middle.head( ).digit( ) , delay( ( ) =&gt; <span class="hljs-keyword">this</span>.middle.tail( ) ) , <span class="hljs-keyword">this</span>.right ) ;

		}

		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Deep( <span class="hljs-keyword">this</span>.M , <span class="hljs-keyword">this</span>.left.tail( ) , <span class="hljs-keyword">this</span>.middle , <span class="hljs-keyword">this</span>.right ) ;

	}

	init ( ) {

		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.right <span class="hljs-keyword">instanceof</span> One ) {

			<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.middle.empty( ) ) {
				<span class="hljs-keyword">return</span> _from_digit( <span class="hljs-keyword">this</span>.M , <span class="hljs-keyword">this</span>.left ) ;
			}

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Deep( <span class="hljs-keyword">this</span>.M , <span class="hljs-keyword">this</span>.left , delay( ( ) =&gt; <span class="hljs-keyword">this</span>.middle.init( ) ) , <span class="hljs-keyword">this</span>.middle.last( ).digit( ) ) ;

		}

		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Deep( <span class="hljs-keyword">this</span>.M , <span class="hljs-keyword">this</span>.left , <span class="hljs-keyword">this</span>.middle , <span class="hljs-keyword">this</span>.right.init( ) ) ;

	}

	cons ( value )  {

		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.left <span class="hljs-keyword">instanceof</span> Four ) {

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Deep(
				<span class="hljs-keyword">this</span>.M ,
				<span class="hljs-keyword">new</span> Two( value , <span class="hljs-keyword">this</span>.left.head( ) ) ,
				<span class="hljs-keyword">this</span>.middle.cons( <span class="hljs-keyword">this</span>.left.tail( ).node( <span class="hljs-keyword">this</span>.M ) ) ,
				<span class="hljs-keyword">this</span>.right
			) ;

		}

		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Deep( <span class="hljs-keyword">this</span>.M , <span class="hljs-keyword">this</span>.left.cons( value ) , <span class="hljs-keyword">this</span>.middle , <span class="hljs-keyword">this</span>.right ) ;

	}

	push ( value ) {

		<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.right <span class="hljs-keyword">instanceof</span> Four ) {

			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Deep(
				<span class="hljs-keyword">this</span>.M ,
				<span class="hljs-keyword">this</span>.left ,
				<span class="hljs-keyword">this</span>.middle.push( <span class="hljs-keyword">this</span>.right.init( ).node( <span class="hljs-keyword">this</span>.M ) ) ,
				<span class="hljs-keyword">new</span> Two( <span class="hljs-keyword">this</span>.right.last( ) , value )
			) ;

		}

		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Deep( <span class="hljs-keyword">this</span>.M , <span class="hljs-keyword">this</span>.left , <span class="hljs-keyword">this</span>.middle , <span class="hljs-keyword">this</span>.right.push( value ) ) ;

	}

	concat ( other ) {

		<span class="hljs-keyword">return</span> app3( <span class="hljs-keyword">this</span> , [ ] , other ) ;

	}

	*[<span class="hljs-built_in">Symbol</span>.iterator] ( ) {

		<span class="hljs-keyword">yield</span>* <span class="hljs-keyword">this</span>.left ;
		<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> node <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.middle ) <span class="hljs-keyword">yield</span>* node ;
		<span class="hljs-keyword">yield</span>* <span class="hljs-keyword">this</span>.right ;

	}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>It is assumed that p(|this|) is true.</p></div></div><div class="code"><div class="wrapper">	splitTree ( p , i ) {

		<span class="hljs-keyword">const</span> { left , middle , right , M } = <span class="hljs-keyword">this</span> ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>see if the split point is inside the left tree</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">const</span> leftMeasure = M.plus( i , left.measure( M ) ) ;
		<span class="hljs-keyword">if</span> ( p( leftMeasure ) ) {
			<span class="hljs-keyword">const</span> split = left.splitDigit( p , i , M ) ;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Split(
				_from_small_list( M , split.left ) ,
				split.middle ,
				_deepL( M , split.right , middle , right )
			) ;
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>see if the split point is inside the middle tree</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">const</span> midMeasure = M.plus( leftMeasure , middle.measure( ) ) ;

		<span class="hljs-keyword">if</span> ( p( midMeasure ) ) {
			<span class="hljs-keyword">const</span> midSplit = middle.splitTree( p , leftMeasure ) ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>midsplit.middle is a Node since middle is a Tree ( Node a )</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">const</span> split = midSplit.middle.digit( ).splitDigit( p , M.plus( leftMeasure , midSplit.left.measure( ) ) , M ) ;
			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Split(
				_deepR( M , left , midSplit.left, split.left ) ,
				split.middle ,
				_deepL( M , split.right , midSplit.right , right )
			) ;
		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>the split point is in the right tree</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">const</span> split = right.splitDigit( p , midMeasure , M ) ;
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Split(
			_deepR( M , left , middle , split.left ) ,
			split.middle ,
			_from_small_list( M , split.right )
		) ;
	}

	split ( p ) {

		<span class="hljs-keyword">if</span> ( p( <span class="hljs-keyword">this</span>.measure( ) ) ) {
			<span class="hljs-keyword">const</span> split = <span class="hljs-keyword">this</span>.splitTree( p , <span class="hljs-keyword">this</span>.M.zero( ) ) ;
			<span class="hljs-keyword">return</span> [ split.left , split.right.cons( split.middle ) ] ;
		}

		<span class="hljs-keyword">return</span> [ <span class="hljs-keyword">this</span> , <span class="hljs-keyword">new</span> Empty( <span class="hljs-keyword">this</span>.M ) ] ;

	}

}</div></div></div></div></body></html>